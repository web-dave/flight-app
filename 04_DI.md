# Dependency Injection: Deep Dive

[[TOC]]

For this lab, checkout the branch `lab3024-di-starter`:

```
git add *
git stash
git checkout lab3024-di-starter
```

## Providing Services

In this lab, you use a simple logger. For this, you need to provide some services.

1. Have a look to the simple logger implementation in the folder `shared/logger`.

1. Open the file `home.component.ts` (`src/app/home/home.component.ts`) and inject the `LoggerService`. Use it to log out some messages:

   <details>
   <summary>Show Code</summary>

   ```diff
   -import { Component } from '@angular/core';
   +import { Component, inject } from '@angular/core';
    import { CommonModule } from '@angular/common';
   +import { LoggerService } from '../shared/logger/logger';

    @Component({
      selector: 'app-home',

   [...]

      templateUrl: './home.component.html',
      styleUrls: ['./home.component.css'],
    })
   -export class HomeComponent {}
   +export class HomeComponent {
   +  logger = inject(LoggerService);
   +
   +  constructor() {
   +    this.logger.debug('home', 'debug');
   +    this.logger.info('home', 'info');
   +    this.logger.error('home', 'error');
   +  }
   +}
   ```

   </details><br>

1. Switch to the file `main.ts` (`src/main.ts`) and provide the following services needed by the logger:

   <details>
   <summary>Show Code</summary>

   ```diff
    import {
    import { AppComponent } from './app/app.component';
    import { APP_ROUTES } from './app/app.routes';
    import { NextFlightsModule } from './app/next-flights/next-flights.module';
   +import {
   +  DefaultLogFormatter,
   +  LogFormatter,
   +} from './app/shared/logger/log-formatter';
   +import { LogLevel } from './app/shared/logger/log-level';
   +import { LoggerService } from './app/shared/logger/logger';
   +import { LoggerConfig } from './app/shared/logger/logger-config';

    bootstrapApplication(AppComponent, {
      providers: [

   [...]

        provideRouter(APP_ROUTES, withPreloading(PreloadAllModules)),
        importProvidersFrom(NextFlightsModule),
        importProvidersFrom(MatDialogModule),
   +
   +    // Logger
   +    LoggerService,
   +    {
   +      provide: LoggerConfig,
   +      useValue: {
   +        level: LogLevel.INFO,
   +      },
   +    },
   +    {
   +      provide: LogFormatter,
   +      useClass: DefaultLogFormatter,
   +    },
      ],
    });
   ```

   </details><br>

1. Test your modifications:

   ```bash
   ng serve -o
   ```

## Exchanging a Service

Now, let's use DI to exchange the LogFormatter used by a custom one.

1. Create a file `custom-log-formatter.ts` (`src/app/shared/logger/custom-log-formatter.ts`) with a custom implementation of the `LogFormatter` interface:

   <details>
   <summary>Show Code</summary>

   ```typescript
   import { Injectable } from "@angular/core";
   import { DefaultLogFormatter } from "./log-formatter";
   import { LogLevel } from "./log-level";

   @Injectable()
   export class CustomLogFormatter extends DefaultLogFormatter {
     override format(level: LogLevel, categorie: string, msg: string): string {
       const formatted = super.format(level, categorie, msg);
       const date = new Date().toISOString();
       return `<${date}> ${formatted}`;
     }
   }
   ```

   </details><br>

1. Open the file `main.ts` (`src/main.ts`) and register your new `CustomLogFormatter` instead of the `DefaultLogFormatter`:

   <details>
   <summary>Show Code</summary>

   ```diff
    import {
    import { AppComponent } from './app/app.component';
    import { APP_ROUTES } from './app/app.routes';
    import { NextFlightsModule } from './app/next-flights/next-flights.module';
   +import { CustomLogFormatter } from './app/shared/logger/custom-log-formatter';
    import {
      DefaultLogFormatter,
      LogFormatter,

   [...]

        },
        {
          provide: LogFormatter,
   -      useClass: DefaultLogFormatter,
   +      useClass: CustomLogFormatter,
        },
      ],
    });
   ```

   </details><br>

1. Test your modifications:

   ```bash
   ng serve -o
   ```

## Using Multi Providers

In this lab, you are going to add an abstract `LogAppender` class with a default implementation. A `LogAppender` is responsible for adding the messages to a log. The default implementation just delegates to `console.log`.

Other than before, `LogAppender`s are registered via a multi provider. Hence, there can be several at a given time and the `LoggerService` will use all of them.

1. Add a file `log-appender.ts` (`src/app/shared/logger/log-appender.ts`) with an abstract `LogAppender` class and a default implementation:

   <details>
   <summary>Show Code</summary>

   ```typescript
   import { Injectable, InjectionToken } from "@angular/core";
   import { LogLevel } from "./log-level";

   export abstract class LogAppender {
     abstract append(level: LogLevel, category: string, msg: string): void;
   }

   @Injectable()
   export class DefaultLogAppender implements LogAppender {
     append(level: LogLevel, category: string, msg: string): void {
       console.log(msg);
     }
   }

   export const LOG_APPENDERS = new InjectionToken<LogAppender[]>(
     "LOG_APPENDERS"
   );
   ```

   </details><br>

   **Hint:** As Arrays cannot be used as DI tokens, we go with an `InjectionToken<LogAppender[]>` here.

1. Switch to the file `logger.ts` (`src/app/shared/logger/logger.ts`) and inject all `LogAppender` implementations. Forward the received log messages to them:

   <details>
   <summary>Show Code</summary>

   ```diff
    import { inject, Injectable } from '@angular/core';
   +import { LOG_APPENDERS } from './log-appender';
    import { LogFormatter } from './log-formatter';
    import { LogLevel } from './log-level';
    import { LoggerConfig } from './logger-config';

   [...]

    export class LoggerService {
      private formatter = inject(LogFormatter);
      private config = inject(LoggerConfig);
   +  private appenders = inject(LOG_APPENDERS);

      log(level: LogLevel, category: string, msg: string): void {
        if (level < this.config.level) {

   [...]


        const formatted = this.formatter.format(level, category, msg);

   -    console.log(formatted);
   +    for (const a of this.appenders) {
   +      a.append(level, category, formatted);
   +    }
      }

      error(category: string, msg: string): void {
   ```

   </details><br>

1. Open the file `main.ts` (`src/main.ts`) and register your `DefaultLogAppender`:

   <details>
   <summary>Show Code</summary>

   ```diff
    import { AppComponent } from './app/app.component';
    import { APP_ROUTES } from './app/app.routes';
    import { NextFlightsModule } from './app/next-flights/next-flights.module';
    import { CustomLogFormatter } from './app/shared/logger/custom-log-formatter';
   +import {
   +  DefaultLogAppender,
   +  LOG_APPENDERS,
   +} from './app/shared/logger/log-appender';
    import {
      DefaultLogFormatter,
      LogFormatter,

   [...]

          provide: LogFormatter,
          useClass: CustomLogFormatter,
        },
   +    {
   +      provide: LOG_APPENDERS,
   +      useClass: DefaultLogAppender,
   +      multi: true,
   +    },
      ],
    });
   ```

   </details><br>

1. Test your modifications:

   ```bash
   ng serve -o
   ```

If you want, you can try to register further custom implementations of the `LogAppender` in addition.

## Add a Standalone API

Now, to make setting up the Logger easier, let's add a Standalone API for it.

1. Open the file `logger-config.ts` (`src/app/shared/logger/logger-config.ts`) and add properties for defining a `LogFormatter` as well as an array of `LogAppenders` to the configuration:

   <details>
   <summary>Show Code</summary>

   ```diff
   +import { Type } from '@angular/core';
   +import { DefaultLogAppender, LogAppender } from './log-appender';
   +import { DefaultLogFormatter, LogFormatter } from './log-formatter';
    import { LogLevel } from './log-level';

    export abstract class LoggerConfig {
      abstract level: LogLevel;
   +  abstract formatter: Type<LogFormatter>;
   +  abstract appenders: Type<LogAppender>[];
    }

    export const defaultConfig: LoggerConfig = {
      level: LogLevel.DEBUG,
   +  formatter: DefaultLogFormatter,
   +  appenders: [DefaultLogAppender],
    };
   ```

   </details><br>

1. Create a file `provider.ts` (`src/app/shared/logger/provider.ts`) with a factory function `provideLogger` that takes the `LoggerConfig` and returns the needed providers:

   <details>
   <summary>Show Code</summary>

   ```typescript
   import {
     EnvironmentProviders,
     makeEnvironmentProviders,
   } from "@angular/core";
   import { LOG_APPENDERS } from "./log-appender";
   import { LogFormatter } from "./log-formatter";
   import { LoggerService } from "./logger";
   import { defaultConfig, LoggerConfig } from "./logger-config";

   export function provideLogger(
     config: Partial<LoggerConfig>
   ): EnvironmentProviders {
     const merged = { ...defaultConfig, ...config };

     return makeEnvironmentProviders([
       LoggerService,
       {
         provide: LoggerConfig,
         useValue: merged,
       },
       {
         provide: LogFormatter,
         useClass: merged.formatter,
       },
       merged.appenders.map((a) => ({
         provide: LOG_APPENDERS,
         useClass: a,
         multi: true,
       })),
     ]);
   }
   ```

   </details><br>

1. Switch to the file `main.ts` (`src/main.ts`) and use the factory function instead of manually setting up the providers for the logger:

   <details>
   <summary>Show Code</summary>

   ```diff
    import {
    import { LogLevel } from './app/shared/logger/log-level';
    import { LoggerService } from './app/shared/logger/logger';
    import { LoggerConfig } from './app/shared/logger/logger-config';
   +import { provideLogger } from './app/shared/logger/provider';

    bootstrapApplication(AppComponent, {
      providers: [

   [...]

        importProvidersFrom(NextFlightsModule),
        importProvidersFrom(MatDialogModule),

   -    // Logger
   -    LoggerService,
   -    {
   -      provide: LoggerConfig,
   -      useValue: {
   -        level: LogLevel.INFO,
   -      },
   -    },
   -    {
   -      provide: LogFormatter,
   -      useClass: CustomLogFormatter,
   -    },
   -    {
   -      provide: LOG_APPENDERS,
   -      useClass: DefaultLogAppender,
   -      multi: true,
   -    },
   -    CustomLogAppender,
   -    {
   -      provide: LOG_APPENDERS,
   -      useExisting: CustomLogAppender,
   -      multi: true,
   -    },
   +    provideLogger({
   +      level: LogLevel.INFO,
   +    }),
      ],
    });
   ```

   </details><br>

1. Test your modifications:

   ```bash
   ng serve -o
   ```

## Bonus: Providing an Optional Feature\*\*

In this lab, you add an optional color feature that prints out the log messages in different colors.

To make this easier, we directly write out some control characters instead of using a npm lib for this task.

1. Add a file `color-config.ts` (`src/app/shared/logger/color-config.ts`) with a configuration for the color feature. It should provide a color core for each log level:

   <details>
   <summary>Show Code</summary>

   ```typescript
   export abstract class ColorConfig {
     abstract debug: number;
     abstract info: number;
     abstract error: number;
   }

   // Color Code from https://en.m.wikipedia.org/wiki/ANSI_escape_code#Colors
   export const defaultColorConfig: ColorConfig = {
     debug: 32,
     info: 34,
     error: 31,
   };
   ```

   </details><br>

1. Add a file `features.ts` (`src/app/shared/logger/features.ts`) with an interface `LoggerFeature` describing features for the logger. Each feature has a property `kind` and a `providers` array:

   <details>
   <summary>Show Code</summary>

   ```typescript
   import { Provider } from "@angular/core";

   export enum LoggerFeatureKind {
     COLOR,
     OTHER_FEATURE,
     ADDITIONAL_FEATURE,
   }

   export interface LoggerFeature {
     kind: LoggerFeatureKind;
     providers: Provider[];
   }
   ```

   </details><br>

   **Remarks:** The kind is an enum used to identify the kind of feature later.

1. Add a file `color.service.ts` (`src/app/shared/logger/color.service.ts`) with the implementation of a `ColorService`:

   <details>
   <summary>Show Code</summary>

   ```typescript
   import { inject, Injectable } from "@angular/core";
   import { ColorConfig } from "./color-config";
   import { LogLevel } from "./log-level";

   export abstract class ColorService {
     abstract apply(level: LogLevel, msg: string): string;
   }

   @Injectable()
   export class DefaultColorService implements ColorService {
     config = inject(ColorConfig);

     apply(level: LogLevel, msg: string): string {
       const key = LogLevel[level].toLowerCase() as keyof ColorConfig;
       const color = this.config[key];

       // For the sake of simplicity, we don't use an external
       // library like chalk here. Instead, we just send
       // commands to the console for controlling the color
       return `\x1b[${color}m${msg}\x1b[0m`;
     }
   }
   ```

   </details><br>

1. Add a file `color.ts` (`src/app/shared/logger/color.ts`) with a provider function for the color feature. It takes a `ColorConfig` object and returns a `LoggerFeature`:

   <details>
   <summary>Show Code</summary>

   ```typescript
   import { ColorConfig, defaultColorConfig } from "./color-config";
   import { ColorService, DefaultColorService } from "./color.service";
   import { LoggerFeature, LoggerFeatureKind } from "./features";

   export function withColor(config?: Partial<ColorConfig>): LoggerFeature {
     const internal = { ...defaultColorConfig, ...config };

     return {
       kind: LoggerFeatureKind.COLOR,
       providers: [
         {
           provide: ColorConfig,
           useValue: internal,
         },
         {
           provide: ColorService,
           useClass: DefaultColorService,
         },
       ],
     };
   }
   ```

   </details><br>

1. Open the file `provider.ts` (`src/app/shared/logger/provider.ts`) and adjust it to respect several features passed via a rest parameter:

   <details>
   <summary>Show Code</summary>

   ```diff
    import { EnvironmentProviders, makeEnvironmentProviders } from '@angular/core';
   +import { LoggerFeature, LoggerFeatureKind } from './features';
    import { LOG_APPENDERS } from './log-appender';
    import { LogFormatter } from './log-formatter';
    import { LoggerService } from './logger';
    import { defaultConfig, LoggerConfig } from './logger-config';

    export function provideLogger(
   -  config: Partial<LoggerConfig>
   +  config: Partial<LoggerConfig>,
   +  ...features: LoggerFeature[]
    ): EnvironmentProviders {
      const merged = { ...defaultConfig, ...config };

   +  const colorFeatures =
   +    features?.filter((f) => f.kind === LoggerFeatureKind.COLOR)?.length ?? 0;
   +
   +  if (colorFeatures > 1) {
   +    throw new Error('Only one color feature allowed for logger!');
   +  }
   +
      return makeEnvironmentProviders([
        LoggerService,
        {

   [...]

          useClass: a,
          multi: true,
        })),
   +    features.map((f) => f.providers),
      ]);
    }
   ```

   </details><br>

1. Switch to the file `log-appender.ts` (`src/app/shared/logger/log-appender.ts`) and adjust it to pick up the optional color feature if it's available:

   <details>
   <summary>Show Code</summary>

   ```diff
   -import { Injectable, InjectionToken } from '@angular/core';
   +import { inject, Injectable, InjectionToken } from '@angular/core';
   +import { ColorService } from './color.service';
    import { LogLevel } from './log-level';

    export abstract class LogAppender {

   [...]


    @Injectable()
    export class DefaultLogAppender implements LogAppender {
   +  colorService = inject(ColorService, { optional: true, self: true });
   +
      append(level: LogLevel, category: string, msg: string): void {
   +    if (this.colorService) {
   +      msg = this.colorService.apply(level, msg);
   +    }
        console.log(msg);
      }
    }
   ```

   </details><br>

   **Remarks:** The second optional argument in `inject` is used to define the service as optional. Otherwise, an exception would be thrown if the requested service was unknown.

1. Open the file `main.ts` (`src/main.ts`) and activate the new color feature:

   <details>
   <summary>Show Code</summary>

   ```diff
    import {
    import { AppComponent } from './app/app.component';
    import { APP_ROUTES } from './app/app.routes';
    import { NextFlightsModule } from './app/next-flights/next-flights.module';
   -import { CustomLogAppender } from './app/shared/logger/custom-log-appender';
   -import { CustomLogFormatter } from './app/shared/logger/custom-log-formatter';
   -import {
   -  DefaultLogAppender,
   -  LOG_APPENDERS,
   -} from './app/shared/logger/log-appender';
   -import {
   -  DefaultLogFormatter,
   -  LogFormatter,
   -} from './app/shared/logger/log-formatter';
   -import { LogLevel } from './app/shared/logger/log-level';
   -import { LoggerService } from './app/shared/logger/logger';
   -import { LoggerConfig } from './app/shared/logger/logger-config';
   +import { withColor } from './app/shared/logger/color';
    import { provideLogger } from './app/shared/logger/provider';

    bootstrapApplication(AppComponent, {

   [...]

        importProvidersFrom(NextFlightsModule),
        importProvidersFrom(MatDialogModule),

   -    provideLogger({
   -      level: LogLevel.INFO,
   -    }),
   +    provideLogger({}, withColor()),
      ],
    });
   ```

   </details><br>

1. Test your modifications:

   ```bash
   ng serve -o
   ```

## Bonus: Using Functional Services\*

To make our logger more lightweight, here, we switch out the class-based LogFormatter by a functional one.

1. Open the file `log-formatter.ts` (`src/app/shared/logger/log-formatter.ts`) and replace the `LogFormatter` class by a type for a function. Also, replace the default implementation by a function:

   <details>
   <summary>Show Code</summary>

   ```diff
   -import { Injectable } from '@angular/core';
   +import { InjectionToken } from '@angular/core';
    import { LogLevel } from './log-level';

   -export abstract class LogFormatter {
   -  abstract format(level: LogLevel, category: string, msg: string): string;
   -}
   +export const LOG_FORMATTER = new InjectionToken<LogFormatFn>('LOG_FORMATTER');

   -@Injectable()
   -export class DefaultLogFormatter implements LogFormatter {
   -  format(level: LogLevel, category: string, msg: string): string {
   -    const levelString = LogLevel[level].padEnd(5);
   -    return `[${levelString}] ${category.toUpperCase()} ${msg}`;
   -  }
   -}
   +export type LogFormatFn = (
   +  level: LogLevel,
   +  category: string,
   +  msg: string
   +) => string;
   +
   +export const defaultLogFormatFn: LogFormatFn = (level, category, msg) => {
   +  const levelString = LogLevel[level].padEnd(5);
   +  return `[${levelString}] ${category.toUpperCase()} ${msg}`;
   +};
   ```

   </details><br>

   **Remarks:** As a type cannot be used as a DI token, let's go with an `InjectionToken<LogFormatFn>`.

1. Switch to the file `logger-config.ts` (`src/app/shared/logger/logger-config.ts`) and adjust the configuration so that functional formatter can be used:

   <details>
   <summary>Show Code</summary>

   ```diff
    import { Type } from '@angular/core';
    import { DefaultLogAppender, LogAppender } from './log-appender';
   -import { DefaultLogFormatter, LogFormatter } from './log-formatter';
   +import { defaultLogFormatFn, LogFormatFn } from './log-formatter';
    import { LogLevel } from './log-level';

    export abstract class LoggerConfig {
      abstract level: LogLevel;
   -  abstract formatter: Type<LogFormatter>;
   +  abstract formatter: LogFormatFn;
      abstract appenders: Type<LogAppender>[];
    }

    export const defaultConfig: LoggerConfig = {
      level: LogLevel.DEBUG,
   -  formatter: DefaultLogFormatter,
   +  formatter: defaultLogFormatFn,
      appenders: [DefaultLogAppender],
    };
   ```

   </details><br>

1. Open the file `logger.ts` (`src/app/shared/logger/logger.ts`) and adjust it to the new functional formatter:

   <details>
   <summary>Show Code</summary>

   ```diff
    import { inject, Injectable } from '@angular/core';
    import { LOG_APPENDERS } from './log-appender';
   -import { LogFormatter } from './log-formatter';
   +import { LOG_FORMATTER } from './log-formatter';
    import { LogLevel } from './log-level';
    import { LoggerConfig } from './logger-config';

    @Injectable()
    export class LoggerService {
   -  private formatter = inject(LogFormatter);
   +  private formatter = inject(LOG_FORMATTER);
      private config = inject(LoggerConfig);
      private appenders = inject(LOG_APPENDERS);

   [...]

          return;
        }

   -    const formatted = this.formatter.format(level, category, msg);
   +    const formatted = this.formatter(level, category, msg);

        for (const a of this.appenders) {
          a.append(level, category, formatted);
   ```

   </details><br>

1. Open the file `provider.ts` (`src/app/shared/logger/provider.ts`) and provide the functional formatter with `useValue` instead of with `useClass`:

   <details>
   <summary>Show Code</summary>

   ```diff
    import { EnvironmentProviders, makeEnvironmentProviders } from '@angular/core';
    import { LoggerFeature, LoggerFeatureKind } from './features';
    import { LOG_APPENDERS } from './log-appender';
   -import { LogFormatter } from './log-formatter';
   +import { LOG_FORMATTER } from './log-formatter';
    import { LoggerService } from './logger';
    import { defaultConfig, LoggerConfig } from './logger-config';

   [...]

          useValue: merged,
        },
        {
   -      provide: LogFormatter,
   -      useClass: merged.formatter,
   +      provide: LOG_FORMATTER,
   +      useValue: merged.formatter,
        },
        merged.appenders.map((a) => ({
          provide: LOG_APPENDERS,
   ```

   </details><br>

1. Test your modifications:

   ```bash
   ng serve -o
   ```

## Bonus: Experimenting with DI Scopes \*

Now, let's experiment with different DI scopes.

1. Open the file `flight-booking.routes.ts` (`src/app/flight-booking/flight-booking.routes.ts`) and provide an own logger for the lazy `FLIGHT_BOOKING_ROUTES`:

   <details>
   <summary>Show Code</summary>

   ```diff
    import { Routes } from '@angular/router';
   +import { provideLogger } from '../shared/logger/provider';
    import { FlightEditComponent } from './flight-edit/flight-edit.component';
    import { FlightSearchComponent } from './flight-search/flight-search.component';
    import { PassengerSearchComponent } from './passenger-search/passenger-search.component';

    export const FLIGHT_BOOKING_ROUTES: Routes = [
      {
   -    path: 'flight-search',
   -    component: FlightSearchComponent,
   -  },
   -  {
   -    path: 'flight-edit/:id',
   -    component: FlightEditComponent,
   -  },
   -  {
   -    path: 'passenger-search',
   -    component: PassengerSearchComponent,
   +    path: '',
   +    providers: [
   +      provideLogger({
   +        formatter: (lvl, cat, msg) => [lvl, cat, msg].join(';'),
   +      }),
   +    ],
   +    children: [
   +      {
   +        path: 'flight-search',
   +        component: FlightSearchComponent,
   +      },
   +      {
   +        path: 'flight-edit/:id',
   +        component: FlightEditComponent,
   +      },
   +      {
   +        path: 'passenger-search',
   +        component: PassengerSearchComponent,
   +      },
   +    ],
      },
    ];
   ```

   </details><br>

1. Open the file `passenger-search.component.ts` (`src/app/flight-booking/passenger-search/passenger-search.component.ts`) and use the logger to print out some messages:

   <details>
   <summary>Show Code</summary>

   ```diff
    import { Component } from '@angular/core';
    import { CommonModule } from '@angular/common';
   +import { LoggerService } from 'src/app/shared/logger/logger';

    @Component({
      selector: 'app-passenger-search',

   [...]

      templateUrl: './passenger-search.component.html',
      styleUrls: ['./passenger-search.component.css'],
    })
   -export class PassengerSearchComponent {}
   +export class PassengerSearchComponent {
   +  constructor(logger: LoggerService) {
   +    logger.info('passenger search', 'info');
   +  }
   +}
   ```

   </details><br>

1. Start your application and move to the PassengerSearchComponent. Now, only the logger registered at route level is used:

   ```bash
   ng serve -o
   ```

1. Open the file `logger.ts` (`src/app/shared/logger/logger.ts`) and adjust it to also delegate to a logger implementation in the parent scope:

   <details>
   <summary>Show Code</summary>

   ```diff
    export class LoggerService {
      private config = inject(LoggerConfig);
      private appenders = inject(LOG_APPENDERS);

   +  private parentLogger = inject(LoggerService, {
   +    optional: true,
   +    skipSelf: true,
   +  });
   +
      log(level: LogLevel, category: string, msg: string): void {
        if (level < this.config.level) {
          return;

   [...]

        for (const a of this.appenders) {
          a.append(level, category, formatted);
        }
   +
   +    if (this.parentLogger) {
   +      this.parentLogger.log(level, category, msg);
   +    }
      }

      error(category: string, msg: string): void {
   ```

   </details><br>

1. Start your application and move to the PassengerSearchComponent. Now, both loggers should be used:

   ```bash
   ng serve -o
   ```

**Remarks:** This pattern is not needed often, but it helps to show that there are several scopes in place. An example for this pattern is the new `HttpClient` that now can also trigger `HttpInterceptors` in the parent scope.
